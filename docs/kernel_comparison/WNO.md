# Orignal code and modified code comparison of Wavelet Neural Operator kernels

## 1D Wavelet Convolution

| **Aspect**                          | **Original (`WaveConv1d`)**                                                                                                                                             | **Modified (`SpectralConvWavelet1D`)**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | **Comments on Logic**                                                                                                                                                                                                                                                                       |
|------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Wavelet transform**              | - Uses **`DWT1D(wave, J=level, mode=mode)`**.  <br/>- If input length > or < `self.size`, it adjusts the wavelet `level` by computing a `factor` from `log2(...)`. <br/>- Then applies `dwt(x)`.                                                                                                                 | - Also uses **`DWT1D(...)`** with adjusted `level + factor` or `level - factor` similarly, based on `log2(...)`. <br/>- The difference is in additional checks for input size vs. defined `wavelet_size` (raises error if input < wavelet_size). <br/>- Otherwise, the wavelet transform logic is nearly the same.                                                                                                                                                                                                                                                                                                                                                                             | Both do a 1D DWT, adjusting the decomposition level based on the input’s shape relative to a “reference” shape. The approach of conditionally computing the wavelet transform at `level ± factor` is consistent.                                                                                                                   |
| **Weights / Kernel**               | - Two parameters: **`weights1`** (for low-frequency/approx. coeffs) and **`weights2`** (for high-frequency/detailed coeffs). <br/>- Shapes: `[in_channels, out_channels, modes]`. | - A single **`self.weight`** with shape `[2, in_channels, out_channels, modes1]`, where the first index presumably corresponds to approximate vs. detail coefficients. <br/>- Logically, it still has 2 sets of weights: `weight[0, ...]` for approximation, `weight[1, ...]` for detail.                                                                                                                   | Conceptually the same: two separate kernel sets for approximate and detail wavelet components. The modified code merges them into one tensor of shape `[2, inC, outC, ~]`.                                                                                                                  |
| **Multiplying wavelet coefficients** | - Multiplication with `einsum("bix, iox->box", input, weights)` for each portion (approx. vs detail).                                                                                              | - Similar: uses the same **`torch.einsum("bix, iox->boxy")`** style (1D variant is `"bix, iox->box"`). <br/>- Splits the big `self.weight` along its first dimension = 2.                                                                                                                                                                  | Both do element-wise multiplication in wavelet domain. The difference is mostly in how the code is arranged (two separate calls vs indexing the first dimension).                                                                                                                           |
| **Zero out higher-level wavelet coeffs** | - After computing wavelet coefficients, it sets the “higher-level” ones to zero by only reassigning the final level’s approximation & detail with `weights1` & `weights2`. | - Also “zeros out” the higher-level sub-bands by constructing `out_coeff` as a list of zero tensors, except the last element is assigned with the multiplied detail.                                                                                                                                                                | Same conceptual approach: only the final scale wavelet coefficients are reweighted. The rest are set to zero.                                                                                                                                                                             |
| **Inverse transform**              | - Uses `IDWT1D(wave, mode=mode)` to invert.                                                                                                                                 | - Similarly calls `IDWT1D(...)` with the adjusted or normal level, merges `out_ft, out_coeff`.                                                                                                                                                                                                                                                                                   | Both do a standard inverse wavelet transform.                                                                                                                                                                                                                                              |
| **Overall logical match**          | **Yes**: The steps—**(1) wavelet transform → (2) multiply coefficients → (3) inverse**—are consistent. The shape handling is a bit more robust in the modified code, but the underlying logic is the same.                                               | **Yes**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | The modifications mostly revolve around how parameters are stored and additional shape checks, not the fundamental method.                                                                                                                                                                |


## 2D Wavelet Convolution (Discrete)
| **Aspect**                          | **Original (`WaveConv2d`)**                                                                                                                                                       | **Modified (`SpectralConvWavelet2D`)**                                                                                                                                                                                                                                                                                                                                                                                                                       | **Comments on Logic**                                                                                                                                                                                                                                                                       |
|------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Wavelet transform**              | - Uses **`DWT(J=level, wave, mode=mode)`**. <br/>- Dynamically adjusts `level ± factor` if input’s last dimension differs from the reference `self.size[-1]`. <br/>- Then calls `dwt(x)` to get `(x_ft, x_coeff)`. | - Also uses **`DWT(J=wavelet_level±factor, wave=wavelet_filter, mode=wavelet_mode)`**. <br/>- Additional shape checks/warnings about the input resolution. <br/>- Otherwise, logic is essentially the same: do a 2D wavelet transform, get `(approx, [details])`.                                                                                                  | Both are doing a 2D DWT with optional up/down adjustments in level. The difference is that the modified code has extra checks/warnings regarding shape consistency.                                                                                                                         |
| **Weights / Kernel**               | - Four sets of wavelet filters: `weights1` (approx), `weights2` (horizontal detail), `weights3` (vertical detail), `weights4` (diagonal detail). <br/>- Each has shape `[inC, outC, modes1, modes2]`. | - The modified code merges them into `weight` with shape `[4, inC, outC, modes1, modes2]`. Indices 0..3 correspond to those four wavelet sub-bands (approx, horizontal, vertical, diagonal). <br/>- The usage is consistent: `weight[0, ...]` for approx, `weight[1, ...]` for horizontal, etc. | Conceptually the same approach: four sets of trainable filters for the final-level wavelet sub-bands. Just different ways of storing them (4 separate vs. stacking them in the first dimension).                                                                                              |
| **Multiplying wavelet coefficients** | - For the final scale, does: <br/>`out_ft = mul2d(x_ft, weights1)` <br/>`out_coeff[-1][:,:,0] = mul2d(x_coeff[-1][:,:,0], weights2)`, etc.                                                                                         | - The modified code is near-identical: <br/>`out_ft[..., :modes1_ft, :modes2_ft]  = mul2d(x_ft[..., :modes1_ft, :modes2_ft], weight[0, ...])`, and so on for horizontal, vertical, and diagonal in the final scale.                                                                                      | Both multiply each wavelet sub-band with the corresponding trainable kernel.                                                                                                                                                                                                               |
| **Zero out higher-level wavelet coeffs** | - Uses a list `out_coeff`, sets higher-level sub-bands to zero, only reassigns the last sub-band.                                                                                                                        | - The same logic: `out_coeff = [torch.zeros_like(coeffs) for coeffs in x_coeff]`. Only the final level’s sub-bands are replaced with the multiplied values.                                                                                                                                                                                        | Identical approach to ignoring higher-level wavelet decomposition.                                                                                                                                                                                                                         |
| **Inverse transform**              | - Calls **`IDWT(...)`** to transform back.                                                                                                                                                                              | - Also calls `IDWT(...)`.                                                                                                                                                                                                                                                                                                                                                         | Both reconstruct from the approximate+detail sub-bands.                                                                                                                                                                                                                                    |
| **Overall logical match**          | **Yes**: The *flow*—DWT → multiply final scale → zero out others → IDWT—matches well.                                                                                                                                    | **Yes**                                                                                                                                                                                                                                                                                                                                                                            | The changes are primarily code structure (consolidated weight parameters, shape checks) but not the fundamental wavelet operator logic.                                                                                                                                                    |

## 2D Wavelet Convolution (Dual-Tree / Slim Continuous)
| **Aspect**                          | **Original (`WaveConv2dCwt`)**                                                                                                                                    | **Modified (`SpectralConvWavelet2DCwt`)**                                                                                                                                                                                                                                                                                                                                                                                                                    | **Comments on Logic**                                                                                                                                                                                                                                                                                |
|------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Wavelet transform**              | - Uses **`DTCWTForward(J=level, biort=wavelet1, qshift=wavelet2)`**. <br/>- If input shape is bigger/smaller, again adjusts `level ± factor` for final transform. | - Same usage: **`DTCWTForward(J=wavelet_level±factor, biort=wavelet_filter[0], qshift=wavelet_filter[1])`**. <br/>- Logic for shape-based factor is the same.                                                                                                                                                                                                                                                           | Both do a dual-tree complex wavelet transform, adjusting the level if needed.                                                                                                                                                                                                                         |
| **Weights / Kernel**               | - A set of 1 approximate coefficient weight (weights0) + 12 sub-bands (6 angles × 2 [real, imaginary]) each as a separate parameter. <br/>- In total, 13 parameter sets. | - The modified code merges them into a single parameter with shape `[13, inC, outC, ..., ...]`. Index 0 is the approximate, and 1..12 are detail sub-bands.                                                                                                                                                                                                                                                             | Same concept: 1 approximate sub-band + 6 complex sub-bands (each complex sub-band has 2 parts). The difference is that the original code has them as individually named parameters (weights15r, weights15c, etc.) whereas the new code is a single 5D tensor with index slices for each angle/real-imag part. |
| **Multiplying wavelet coefficients** | - For the final scale: <br/>`out_ft = mul2d( x_ft, weights0 )` <br/>Then, for each angle among 15°, 45°, …, 165°: `<real> = mul2d(x_coeff[...,0], weights..r)`, `<imag> = mul2d(x_coeff[...,1], weights..c)`. | - The modified code likewise does `<approx> = mul2d(x_ft, self.weight[0])`. <br/>Then detail sub-bands: e.g. `out_coeff[-1][:,:,0,...,0] = mul2d( x_coeff[-1][:,:,0,...,0], self.weight[1] )` (for 15r), `..., self.weight[2]` (for 15c), etc. <br/>Indices [1..12] in the first dimension of `weight`. | Both multiply each sub-band (real and imaginary) by a dedicated part of the parameter tensor. The indexing is conceptually the same, just consolidated differently.                                                                                                                                                                            |
| **Zero out higher-level wavelet coeffs** | - The original sets higher-level sub-bands to zeros by building an empty list for `out_coeff` except the final scale.                                                                               | - The same approach: it creates a `out_coeff` list of zero-like sub-bands, then only the final scale’s sub-bands get assigned to the multiplied results.                                                                                                                                                                                                                                                                    | Identical logic in terms of ignoring all but the final decomposition level for learning.                                                                                                                                                                                                                |
| **Inverse transform**              | - Calls **`DTCWTInverse(...)`** to go back to spatial domain.                                                                                                     | - Also calls `DTCWTInverse(...)`.                                                                                                                                                                                                                                                                                                                                                                                       | Both reconstruct from the approximate + detail sub-bands.                                                                                                                                                                                                                                               |
| **Overall logical match**          | **Yes**: The structure—(dual-tree wavelet transform) → (multiply final sub-bands) → (inverse transform)—is preserved.                                                                                    | **Yes**                                                                                                                                                                                                                                                                                                                                                                                                                    | Both handle 13 total sub-bands in the final scale (1 approximate + 6 complex detail each with real/imag). No major logic difference.                                                                                                                                                                    |
## 3D Wavelet Convolution
| **Aspect**                          | **Original (`WaveConv3d`)**                                                                                                                                                                             | **Modified (`SpectralConvWavelet3D`)**                                                                                                                                                                                                                                                                                                                                                                                                                              | **Comments on Logic**                                                                                                                                                                                                                                                            |
|------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Wavelet transform**              | - Uses **`wavedec3(x[i,...], pywt.Wavelet(wavelet), level=level±factor, mode=mode)`**. <br/>- Per-`batch` iteration: for each sample i in range(batchsize). <br/>- Factor derived from `log2(...)`. | - Also does `wavedec3(..., level=wavelet_level±factor)` for each item in the batch. <br/>- Identical approach: loop over `i` in `range(x.shape[0])`. <br/>- The difference is that the new code builds a new `out_coeff` structure (with shape `[out_channels, ...]`) instead of doing in-place in the original.                                                                                                    | Both do a 3D wavelet transform per batch item, adjusting the level if input shape is bigger/smaller.                                                                                                                                                                                                                      |
| **Weights / Kernel**               | - 8 sets of kernel weights: `weights1` for `aaa` plus 7 more for `aad, ada, add, daa, dad, dda, ddd`. Each shape is `[inC, outC, x, y, z]`.                                                              | - The modified code stores them in **`self.weight`** with shape `[8, inC, outC, x, y, z]`. Indices 0..7 correspond to `[aaa, aad, ada, add, daa, dad, dda, ddd]`.                                                                                                                                                                                                                                                           | The original code has 8 separate parameters; the modified code has one big parameter with the first dimension enumerating sub-bands. The concept remains the same.                                                                                                                                                       |
| **Multiplying wavelet coefficients** | - After `wavedec3`, it multiplies the final scale’s sub-bands with the corresponding `weightsX` using `mul3d(...)` (`einsum`). <br/>- E.g. `x_coeff[1]['aad'] = mul3d(x_coeff[1]['aad'], self.weights2)`. | - Does the same approach in the loop, but references `self.weight[1]`, `self.weight[2]`, … etc. <br/>- Then constructs an output tuple or dictionary.                                                                                                                                                                                                                                                                         | Both do element-wise multiplication in wavelet domain for the final scale, ignoring further scales. No major difference.                                                                                                                                                                                                 |
| **Zero out higher-level wavelet coeffs** | - In the original, for `jj` in `range(2, level+1)`, sets those `x_coeff[jj]` sub-bands to zeros.                                                                                                      | - Also reassigns higher-level sub-bands to zero by building an empty structure for the final reconstruction. <br/>- The new code sometimes leaves a comment about zeroing out wavelet_level > 1. Implementation details might differ, but the outcome is that only the first scale is used.                                                                                                                            | The idea of ignoring subsequent scales (beyond 1) is consistent: only the final scale’s sub-bands get the learned weights, and everything else is zero.                                                                                                                                                                 |
| **Inverse transform**              | - Calls **`waverec3(...)`** to reconstruct the volume.                                                                                                                                                  | - Also calls `waverec3(...)`.                                                                                                                                                                                                                                                                                                                                                                                                 | Both do the 3D wavelet inverse using PyWavelets.                                                                                                                                                                                                                                                         |
| **Overall logical match**          | **Yes**: (1) Compute 3D wavelet transform → (2) multiply final scale sub-bands → (3) zero out higher scales → (4) inverse.                                                                             | **Yes**                                                                                                                                                                                                                                                                                                                                                                                                                         | The approach is effectively the same. The new version reorganizes parameter storage but does not alter the wavelet-based logic.                                                                                                                                                                                             |
## Overall Summary
From a logical standpoint—focusing on the main steps in each forward method:

Wavelet Transform (possibly with adjusted level ± factor if the input shape differs from the reference).
Prepare Output Coefficients (zero for all scales except the final scale).
Multiply the final scale’s approximate and detail coefficients with the trainable weights.
Inverse Wavelet Transform to get back to the spatial/temporal domain.
Both the Original code and the Modified code follow the same high-level logic in each dimension (1D, 2D, 2D CWT, and 3D). The changes in the Modified code revolve primarily around:

Consolidating multiple weightsX into a single parameter tensor that’s indexed in the first dimension.
Additional shape checks and resolution-scaling factors.
Extra utility classes/methods (ShapeEnforcer, resample, etc.) for flexible resolution handling.
More robust error handling or warnings when input shapes are not as expected.
In short, from the perspective of the original author, the wavelet-based logic (transform → multiply → inverse) is preserved. The differences are primarily in parameter storage structure, shape validations, or small refactoring details—not in the core wavelet-convolution logic.

Hence, yes—the Modified code generally follows the Original code’s logic in all forward functions (1D, 2D, 2D-CWT, 3D).